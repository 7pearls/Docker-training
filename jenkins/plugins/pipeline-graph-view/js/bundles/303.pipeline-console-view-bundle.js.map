{"version":3,"file":"303.pipeline-console-view-bundle.js","mappings":"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","sources":["webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-graph-view/pipeline-graph/main/support/TruncatingLabel.tsx","webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-graph-view/pipeline-graph/main/support/connections.tsx","webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-graph-view/pipeline-graph/main/PipelineGraph.tsx","webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-console-view/pipeline-console/main/data-tree-view.scss?2e34","webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-console-view/pipeline-console/main/DataTreeView.tsx","webpack://pipeline-graph-view-plugin/./src/main/frontend/step-status/StepStatus.tsx","webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-console-view/pipeline-console/main/data-tree-view.scss"],"sourcesContent":["import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\n//--------------------------------------\n//  Safety constants\n//--------------------------------------\n\nconst MINLENGTH = 5; // Minimum size of cut-down text\nconst MAXLOOPS = 50; // Max no of iterations attempting to find the correct size text\n\n//--------------------------------------\n//  Render lifecycle\n//--------------------------------------\n\nenum RenderState {\n  INITIAL,\n  MEASURE, // Mounted, text/props changed, measurement needed.\n  FLUID, // Text too big, in the process of trimming it down\n  STABLE, // Done measuring until props change\n}\n\n//--------------------------------------\n//  Component\n//--------------------------------------\n\ninterface Props {\n  children?: string;\n  style?: Object;\n  className?: string;\n}\n\n/**\n * Multi-line label that will truncate with ellipses\n *\n * Use with a set width + height (or maxWidth / maxHeight) to get any use from it :D\n */\nexport class TruncatingLabel extends React.Component<Props> {\n  //--------------------------------------\n  //  Component state / lifecycle\n  //--------------------------------------\n\n  completeText = \"\"; // Unabridged plain text content\n  innerText = \"\"; // Current innerText of element - includes possible ellipses\n  renderState = RenderState.INITIAL; // Internal rendering lifecycle state\n  checkSizeRequest?: number; // window.requestAnimationFrame handle\n\n  //--------------------------------------\n  //  Binary search state\n  //--------------------------------------\n\n  textCutoffLength = 0; // Last count used to truncate completeText\n  longestGood = 0; // Length of the longest truncated text that fits\n  shortestBad = 0; // Length of the shortest truncated text that does not fit\n  loopCount = 0; // to avoid infinite iteration\n\n  //--------------------------------------\n  //  React Lifecycle\n  //--------------------------------------\n\n  componentWillMount() {\n    this.handleProps(this.props);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    this.handleProps(nextProps);\n  }\n\n  componentDidMount() {\n    this.invalidateSize();\n  }\n\n  componentDidUpdate() {\n    this.invalidateSize();\n  }\n\n  componentWillUnmount() {\n    if (this.checkSizeRequest) {\n      cancelAnimationFrame(this.checkSizeRequest);\n      this.checkSizeRequest = 0;\n    }\n  }\n\n  //--------------------------------------\n  //  Render\n  //--------------------------------------\n\n  render() {\n    const { className = \"\" } = this.props;\n\n    const style: React.CSSProperties = this.props.style || {};\n\n    const mergedStyle: React.CSSProperties = {\n      overflow: \"hidden\",\n      wordWrap: \"break-word\",\n      ...style,\n    };\n\n    if (this.renderState !== RenderState.STABLE) {\n      mergedStyle.opacity = 0;\n    }\n\n    return (\n      <div\n        style={mergedStyle}\n        className={\"TruncatingLabel \" + className}\n        title={this.completeText}\n      >\n        {this.innerText}\n      </div>\n    );\n  }\n\n  //--------------------------------------\n  //  Internal Rendering Lifecycle\n  //--------------------------------------\n\n  handleProps(props: Props) {\n    const { children = \"\" } = props;\n\n    if (typeof children === \"string\") {\n      this.completeText = children;\n    } else if (children === null || children === false) {\n      this.completeText = \"\";\n    } else {\n      console.warn(\n        \"TruncatingLabel - Label children must be string but is\",\n        typeof children,\n        children,\n      );\n      this.completeText = \"Contents must be string\";\n    }\n\n    this.renderState = RenderState.MEASURE;\n    this.innerText = this.completeText;\n    this.loopCount = 0;\n    this.longestGood = MINLENGTH;\n    this.shortestBad = this.innerText.length;\n  }\n\n  invalidateSize() {\n    if (!this.checkSizeRequest) {\n      this.checkSizeRequest = requestAnimationFrame(() => this.checkSize());\n    }\n  }\n\n  checkSize() {\n    this.checkSizeRequest = 0;\n\n    if (this.renderState === RenderState.STABLE) {\n      return; // Nothing to check, no more checks to schedule\n    }\n\n    const thisElement = ReactDOM.findDOMNode(this) as HTMLElement;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } =\n      thisElement;\n\n    const tooBig = scrollHeight > clientHeight || scrollWidth > clientWidth;\n\n    if (this.renderState === RenderState.MEASURE) {\n      // First measurement since mount / props changed\n\n      if (tooBig) {\n        this.renderState = RenderState.FLUID;\n\n        // Set initial params for binary search of length\n        this.longestGood = MINLENGTH;\n        this.textCutoffLength = this.shortestBad = this.innerText.length;\n      } else {\n        this.renderState = RenderState.STABLE;\n        this.forceUpdate(); // Re-render via react so it can update the alpha\n      }\n    }\n\n    if (this.renderState === RenderState.FLUID) {\n      this.loopCount++;\n\n      const lastLength = this.textCutoffLength;\n\n      let keepMeasuring;\n\n      if (this.loopCount >= MAXLOOPS) {\n        // This really shouldn't happen!\n        console.error(\"TruncatingLabel - TOO MANY LOOPS\");\n        keepMeasuring = false;\n      } else if (lastLength <= MINLENGTH) {\n        keepMeasuring = false;\n      } else if (Math.abs(this.shortestBad - this.longestGood) < 2) {\n        // We're done searching, hoorays!\n        keepMeasuring = false;\n      } else {\n        // Update search space\n        if (tooBig) {\n          this.shortestBad = Math.min(this.shortestBad, lastLength);\n        } else {\n          this.longestGood = Math.max(this.longestGood, lastLength);\n        }\n\n        // Calculate the next length and update the text\n        this.textCutoffLength = Math.floor(\n          (this.longestGood + this.shortestBad) / 2,\n        );\n        this.innerText =\n          this.completeText.substr(0, this.textCutoffLength) + \"â€¦\";\n\n        // Bypass react's render loop during the \"fluid\" state for performance\n        thisElement.innerText = this.innerText;\n        keepMeasuring = true;\n      }\n\n      if (keepMeasuring) {\n        this.invalidateSize();\n      } else {\n        this.renderState = RenderState.STABLE;\n        this.forceUpdate(); // Re-render via react so it knows about updated alpha and final content\n      }\n    }\n  }\n}\n","import * as React from \"react\";\n\nimport { nodeStrokeWidth } from \"../support/StatusIcons\";\nimport {\n  CompositeConnection,\n  LayoutInfo,\n  NodeInfo,\n} from \"../PipelineGraphModel\";\nimport { sequentialStagesLabelOffset } from \"../PipelineGraphLayout\";\n\ntype SVGChildren = Array<any>; // Fixme: Maybe refine this? Not sure what should go here, we have working code I can't make typecheck\n\n// Generate a react key for a connection\nfunction connectorKey(leftNode: NodeInfo, rightNode: NodeInfo) {\n  return \"c_\" + leftNode.key + \"_to_\" + rightNode.key;\n}\n\ninterface Props {\n  connections: Array<CompositeConnection>;\n  layout: LayoutInfo;\n}\n\nexport class GraphConnections extends React.Component {\n  props!: Props;\n\n  /**\n   * Generate SVG for a composite connection, which may be to/from many nodes.\n   *\n   * Farms work out to other methods on self depending on the complexity of the line required. Adds all the SVG\n   * components to the elements list.\n   */\n  private renderCompositeConnection(\n    connection: CompositeConnection,\n    svgElements: SVGChildren,\n  ) {\n    const { sourceNodes, destinationNodes, skippedNodes, hasBranchLabels } =\n      connection;\n\n    if (skippedNodes.length === 0) {\n      // Nothing too complicated, use the original connection drawing code\n      this.renderBasicConnections(\n        sourceNodes,\n        destinationNodes,\n        svgElements,\n        hasBranchLabels,\n      );\n    } else {\n      this.renderSkippingConnections(\n        sourceNodes,\n        destinationNodes,\n        skippedNodes,\n        svgElements,\n        hasBranchLabels,\n      );\n    }\n  }\n\n  /**\n   * Connections between adjacent columns without any skipping.\n   *\n   * Adds all the SVG components to the elements list.\n   */\n  private renderBasicConnections(\n    sourceNodes: Array<NodeInfo>,\n    destinationNodes: Array<NodeInfo>,\n    svgElements: SVGChildren,\n    hasBranchLabels: boolean,\n  ) {\n    const { connectorStrokeWidth, nodeSpacingH } = this.props.layout;\n    const halfSpacingH = nodeSpacingH / 2;\n\n    // Stroke props common to straight / curved connections\n    const connectorStroke = {\n      className: \"PWGx-pipeline-connector\",\n      strokeWidth: connectorStrokeWidth,\n    };\n\n    this.renderHorizontalConnection(\n      sourceNodes[0],\n      destinationNodes[0],\n      connectorStroke,\n      svgElements,\n    );\n\n    if (sourceNodes.length === 1 && destinationNodes.length === 1) {\n      return; // No curves needed.\n    }\n\n    // Work out the extents of source and dest space\n    let rightmostSource = sourceNodes[0].x;\n    let leftmostDestination = destinationNodes[0].x;\n\n    for (let i = 1; i < sourceNodes.length; i++) {\n      rightmostSource = Math.max(rightmostSource, sourceNodes[i].x);\n    }\n\n    for (let i = 1; i < destinationNodes.length; i++) {\n      leftmostDestination = Math.min(\n        leftmostDestination,\n        destinationNodes[i].x,\n      );\n    }\n\n    // Collapse from previous node(s) to top column node\n    const collapseMidPointX = Math.round(rightmostSource + halfSpacingH);\n    for (const previousNode of sourceNodes.slice(1)) {\n      this.renderBasicCurvedConnection(\n        previousNode,\n        destinationNodes[0],\n        collapseMidPointX,\n        svgElements,\n      );\n    }\n\n    // Expand from top previous node to column node(s)\n    let expandMidPointX = Math.round(leftmostDestination - halfSpacingH);\n\n    if (hasBranchLabels) {\n      // Shift curve midpoint so that there's room for the labels\n      expandMidPointX -= sequentialStagesLabelOffset;\n    }\n\n    for (const destNode of destinationNodes.slice(1)) {\n      this.renderBasicCurvedConnection(\n        sourceNodes[0],\n        destNode,\n        expandMidPointX,\n        svgElements,\n      );\n    }\n  }\n\n  /**\n   * Renders a more complex connection, that \"skips\" one or more nodes\n   *\n   * Adds all the SVG components to the elements list.\n   */\n  private renderSkippingConnections(\n    sourceNodes: Array<NodeInfo>,\n    destinationNodes: Array<NodeInfo>,\n    skippedNodes: Array<NodeInfo>,\n    svgElements: SVGChildren,\n    hasBranchLabels: boolean,\n  ) {\n    const {\n      connectorStrokeWidth,\n      nodeRadius,\n      terminalRadius,\n      curveRadius,\n      nodeSpacingV,\n      nodeSpacingH,\n    } = this.props.layout;\n\n    const halfSpacingH = nodeSpacingH / 2;\n\n    // Stroke props common to straight / curved connections\n    const connectorStroke = {\n      className: \"PWGx-pipeline-connector\",\n      strokeWidth: connectorStrokeWidth,\n    };\n\n    const skipConnectorStroke = {\n      className: \"PWGx-pipeline-connector-skipped\",\n      strokeWidth: connectorStrokeWidth,\n    };\n\n    const lastSkippedNode = skippedNodes[skippedNodes.length - 1];\n    let leftNode, rightNode;\n\n    //--------------------------------------------------------------------------\n    //  Draw the \"ghost\" connections to/from/between skipped nodes\n\n    leftNode = sourceNodes[0];\n    for (rightNode of skippedNodes) {\n      this.renderHorizontalConnection(\n        leftNode,\n        rightNode,\n        skipConnectorStroke,\n        svgElements,\n      );\n      leftNode = rightNode;\n    }\n    this.renderHorizontalConnection(\n      leftNode,\n      destinationNodes[0],\n      skipConnectorStroke,\n      svgElements,\n    );\n\n    //--------------------------------------------------------------------------\n    //  Work out the extents of source and dest space\n\n    let rightmostSource = sourceNodes[0].x;\n    let leftmostDestination = destinationNodes[0].x;\n\n    for (let i = 1; i < sourceNodes.length; i++) {\n      rightmostSource = Math.max(rightmostSource, sourceNodes[i].x);\n    }\n\n    for (let i = 1; i < destinationNodes.length; i++) {\n      leftmostDestination = Math.min(\n        leftmostDestination,\n        destinationNodes[i].x,\n      );\n    }\n\n    //--------------------------------------------------------------------------\n    //  \"Collapse\" from the source node(s) down toward the first skipped\n\n    leftNode = sourceNodes[0];\n    rightNode = skippedNodes[0];\n\n    for (leftNode of sourceNodes.slice(1)) {\n      const midPointX = Math.round(rightmostSource + halfSpacingH);\n      const leftNodeRadius = leftNode.isPlaceholder\n        ? terminalRadius\n        : nodeRadius;\n      const key = connectorKey(leftNode, rightNode);\n\n      const x1 = leftNode.x + leftNodeRadius - nodeStrokeWidth / 2;\n      const y1 = leftNode.y;\n      const x2 = midPointX;\n      const y2 = rightNode.y;\n\n      const pathData =\n        `M ${x1} ${y1}` +\n        this.svgBranchCurve(x1, y1, x2, y2, midPointX, curveRadius);\n\n      svgElements.push(\n        <path {...connectorStroke} key={key} d={pathData} fill=\"none\" />,\n      );\n    }\n\n    //--------------------------------------------------------------------------\n    //  \"Expand\" from the last skipped node toward the destination nodes\n\n    leftNode = lastSkippedNode;\n\n    let expandMidPointX = Math.round(leftmostDestination - halfSpacingH);\n\n    if (hasBranchLabels) {\n      // Shift curve midpoint so that there's room for the labels\n      expandMidPointX -= sequentialStagesLabelOffset;\n    }\n\n    for (rightNode of destinationNodes.slice(1)) {\n      const rightNodeRadius = rightNode.isPlaceholder\n        ? terminalRadius\n        : nodeRadius;\n      const key = connectorKey(leftNode, rightNode);\n\n      const x1 = expandMidPointX;\n      const y1 = leftNode.y;\n      const x2 = rightNode.x - rightNodeRadius + nodeStrokeWidth / 2;\n      const y2 = rightNode.y;\n\n      const pathData =\n        `M ${x1} ${y1}` +\n        this.svgBranchCurve(x1, y1, x2, y2, expandMidPointX, curveRadius);\n\n      svgElements.push(\n        <path {...connectorStroke} key={key} d={pathData} fill=\"none\" />,\n      );\n    }\n\n    //--------------------------------------------------------------------------\n    //  \"Main\" curve from top of source nodes, around skipped nodes, to top of dest nodes\n\n    leftNode = sourceNodes[0];\n    rightNode = destinationNodes[0];\n\n    const leftNodeRadius = leftNode.isPlaceholder ? terminalRadius : nodeRadius;\n    const rightNodeRadius = rightNode.isPlaceholder\n      ? terminalRadius\n      : nodeRadius;\n    const key = connectorKey(leftNode, rightNode);\n\n    const skipHeight = nodeSpacingV * 0.5;\n    const controlOffsetUpper = curveRadius * 1.54;\n    const controlOffsetLower = skipHeight * 0.257;\n    const controlOffsetMid = skipHeight * 0.2;\n    const inflectiontOffset = Math.round(skipHeight * 0.7071); // cos(45Âº)-ish\n\n    // Start point\n    const p1x = leftNode.x + leftNodeRadius - nodeStrokeWidth / 2;\n    const p1y = leftNode.y;\n\n    // Begin curve down point\n    const p2x = Math.round(skippedNodes[0].x - halfSpacingH);\n    const p2y = p1y;\n    const c1x = p2x + controlOffsetUpper;\n    const c1y = p2y;\n\n    // End curve down point\n    const p4x = skippedNodes[0].x;\n    const p4y = p1y + skipHeight;\n    const c4x = p4x - controlOffsetLower;\n    const c4y = p4y;\n\n    // Curve down midpoint / inflection\n    const p3x = skippedNodes[0].x - inflectiontOffset;\n    const p3y = skippedNodes[0].y + inflectiontOffset;\n    const c2x = p3x - controlOffsetMid;\n    const c2y = p3y - controlOffsetMid;\n    const c3x = p3x + controlOffsetMid;\n    const c3y = p3y + controlOffsetMid;\n\n    // Begin curve up point\n    const p5x = lastSkippedNode.x;\n    const p5y = p4y;\n    const c5x = p5x + controlOffsetLower;\n    const c5y = p5y;\n\n    // End curve up point\n    const p7x = Math.round(lastSkippedNode.x + halfSpacingH);\n    const p7y = rightNode.y;\n    const c8x = p7x - controlOffsetUpper;\n    const c8y = p7y;\n\n    // Curve up midpoint / inflection\n    const p6x = lastSkippedNode.x + inflectiontOffset;\n    const p6y = lastSkippedNode.y + inflectiontOffset;\n    const c6x = p6x - controlOffsetMid;\n    const c6y = p6y + controlOffsetMid;\n    const c7x = p6x + controlOffsetMid;\n    const c7y = p6y - controlOffsetMid;\n\n    // End point\n    const p8x = rightNode.x - rightNodeRadius + nodeStrokeWidth / 2;\n    const p8y = rightNode.y;\n\n    const pathData =\n      `M ${p1x} ${p1y}` +\n      `L ${p2x} ${p2y}` + // 1st horizontal\n      `C ${c1x} ${c1y} ${c2x} ${c2y} ${p3x} ${p3y}` + // Curve down (upper)\n      `C ${c3x} ${c3y} ${c4x} ${c4y} ${p4x} ${p4y}` + // Curve down (lower)\n      `L ${p5x} ${p5y}` + // 2nd horizontal\n      `C ${c5x} ${c5y} ${c6x} ${c6y} ${p6x} ${p6y}` + // Curve up (lower)\n      `C ${c7x} ${c7y} ${c8x} ${c8y} ${p7x} ${p7y}` + // Curve up (upper)\n      `L ${p8x} ${p8y}` + // Last horizontal\n      \"\";\n\n    svgElements.push(\n      <path {...connectorStroke} key={key} d={pathData} fill=\"none\" />,\n    );\n  }\n\n  /**\n   * Simple straight connection.\n   *\n   * Adds all the SVG components to the elements list.\n   */\n  private renderHorizontalConnection(\n    leftNode: NodeInfo,\n    rightNode: NodeInfo,\n    connectorStroke: Object,\n    svgElements: SVGChildren,\n  ) {\n    const { nodeRadius, terminalRadius } = this.props.layout;\n    const leftNodeRadius = leftNode.isPlaceholder ? terminalRadius : nodeRadius;\n    const rightNodeRadius = rightNode.isPlaceholder\n      ? terminalRadius\n      : nodeRadius;\n\n    const key = connectorKey(leftNode, rightNode);\n\n    const x1 = leftNode.x + leftNodeRadius - nodeStrokeWidth / 2;\n    const x2 = rightNode.x - rightNodeRadius + nodeStrokeWidth / 2;\n    const y = leftNode.y;\n\n    svgElements.push(\n      <line {...connectorStroke} key={key} x1={x1} y1={y} x2={x2} y2={y} />,\n    );\n  }\n\n  /**\n   * A direct curve between two nodes in adjacent columns.\n   *\n   * Adds all the SVG components to the elements list.\n   */\n  private renderBasicCurvedConnection(\n    leftNode: NodeInfo,\n    rightNode: NodeInfo,\n    midPointX: number,\n    svgElements: SVGChildren,\n  ) {\n    const { nodeRadius, terminalRadius, curveRadius, connectorStrokeWidth } =\n      this.props.layout;\n    const leftNodeRadius = leftNode.isPlaceholder ? terminalRadius : nodeRadius;\n    const rightNodeRadius = rightNode.isPlaceholder\n      ? terminalRadius\n      : nodeRadius;\n\n    const key = connectorKey(leftNode, rightNode);\n\n    const leftPos = {\n      x: leftNode.x + leftNodeRadius - nodeStrokeWidth / 2,\n      y: leftNode.y,\n    };\n\n    const rightPos = {\n      x: rightNode.x - rightNodeRadius + nodeStrokeWidth / 2,\n      y: rightNode.y,\n    };\n\n    // Stroke props common to straight / curved connections\n    const connectorStroke = {\n      className: \"PWGx-pipeline-connector\",\n      strokeWidth: connectorStrokeWidth,\n    };\n\n    const pathData =\n      `M ${leftPos.x} ${leftPos.y}` +\n      this.svgBranchCurve(\n        leftPos.x,\n        leftPos.y,\n        rightPos.x,\n        rightPos.y,\n        midPointX,\n        curveRadius,\n      );\n\n    svgElements.push(\n      <path {...connectorStroke} key={key} d={pathData} fill=\"none\" />,\n    );\n  }\n\n  /**\n   * Generates an SVG path string for the \"vertical\" S curve used to connect nodes in adjacent columns.\n   */\n  private svgBranchCurve(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    midPointX: number,\n    curveRadius: number,\n  ) {\n    const verticalDirection = Math.sign(y2 - y1); // 1 == curve down, -1 == curve up\n    const w1 = midPointX - curveRadius - x1 + curveRadius * verticalDirection;\n    const w2 = x2 - curveRadius - midPointX - curveRadius * verticalDirection;\n    const v = y2 - y1 - 2 * curveRadius * verticalDirection; // Will be -ive if curve up\n    const cv = verticalDirection * curveRadius;\n\n    return (\n      ` l ${w1} 0` + // first horizontal line\n      ` c ${curveRadius} 0 ${curveRadius} ${cv} ${curveRadius} ${cv}` + // turn\n      ` l 0 ${v}` + // vertical line\n      ` c 0 ${cv} ${curveRadius} ${cv} ${curveRadius} ${cv}` + // turn again\n      ` l ${w2} 0` // second horizontal line\n    );\n  }\n\n  render() {\n    const { connections } = this.props;\n\n    const svgElements: SVGChildren = []; // Buffer for children of the SVG\n\n    connections.forEach((connection) => {\n      this.renderCompositeConnection(connection, svgElements);\n    });\n\n    return <>{svgElements}</>;\n  }\n}\n","import * as React from \"react\";\n\nimport startPollingPipelineStatus from \"./support/startPollingPipelineStatus\";\nimport {\n  CompositeConnection,\n  defaultLayout,\n  NodeLabelInfo,\n  LayoutInfo,\n  NodeColumn,\n  StageInfo,\n} from \"./PipelineGraphModel\";\nimport { layoutGraph } from \"./PipelineGraphLayout\";\nimport { Result } from \"./PipelineGraphModel\";\nimport { Node, SelectionHighlight } from \"./support/nodes\";\nimport {\n  BigLabel,\n  SmallLabel,\n  SequentialContainerLabel,\n} from \"./support/labels\";\nimport { GraphConnections } from \"./support/connections\";\n\ninterface Props {\n  stages: Array<StageInfo>;\n  layout?: Partial<LayoutInfo>;\n  setStages?: (stages: Array<StageInfo>) => void;\n  selectedStage?: StageInfo;\n  path?: string;\n  collapsed?: boolean;\n}\n\ninterface State {\n  nodeColumns: Array<NodeColumn>;\n  connections: Array<CompositeConnection>;\n  bigLabels: Array<NodeLabelInfo>;\n  smallLabels: Array<NodeLabelInfo>;\n  branchLabels: Array<NodeLabelInfo>;\n  measuredWidth: number;\n  measuredHeight: number;\n  layout: LayoutInfo;\n  selectedStage?: StageInfo;\n}\n\nexport class PipelineGraph extends React.Component {\n  props!: Props;\n  state: State;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      nodeColumns: [],\n      connections: [],\n      bigLabels: [],\n      smallLabels: [],\n      branchLabels: [],\n      measuredWidth: 0,\n      measuredHeight: 0,\n      layout: { ...defaultLayout, ...props.layout },\n      selectedStage: props.selectedStage,\n    };\n  }\n\n  componentDidMount() {\n    const onPipelineDataReceived = (data: { stages: Array<StageInfo> }) => {\n      const { stages } = data;\n      this.setState({ stages });\n      this.stagesUpdated(stages);\n    };\n    const onPollingError = (err: Error) => {\n      console.log(\"There was an error when polling the pipeline status\", err);\n    };\n    const onPipelineComplete = () => undefined;\n\n    startPollingPipelineStatus(\n      onPipelineDataReceived,\n      onPollingError,\n      onPipelineComplete,\n      this.props.path ?? this.getTreePath(),\n    );\n  }\n\n  getTreePath() {\n    const url = new URL(window.location.href);\n\n    if (!url.pathname.endsWith(\"pipeline-graph/\")) {\n      return \"pipeline-graph/tree\";\n    }\n\n    return \"tree\";\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    let newState: Partial<State> | undefined;\n    let needsLayout = false;\n\n    if (nextProps.layout != this.props.layout) {\n      newState = {\n        ...newState,\n        layout: { ...defaultLayout, ...this.props.layout },\n      };\n      needsLayout = true;\n    }\n\n    if (nextProps.selectedStage !== this.props.selectedStage) {\n      // If we're just changing selectedStage, we don't need to re-generate the children\n      newState = { ...newState, selectedStage: nextProps.selectedStage };\n    }\n\n    if (nextProps.stages !== this.props.stages) {\n      needsLayout = true;\n    }\n\n    const doLayoutIfNeeded = () => {\n      if (needsLayout) {\n        this.stagesUpdated(nextProps.stages);\n      }\n    };\n\n    if (newState) {\n      // If we need to update the state, then we'll delay any layout changes\n      this.setState(newState, doLayoutIfNeeded);\n    } else {\n      doLayoutIfNeeded();\n    }\n  }\n\n  /**\n   * Main process for laying out the graph. Calls out to PipelineGraphLayout module.\n   */\n  private stagesUpdated(newStages: Array<StageInfo> = []) {\n    if (this.props.setStages != undefined) {\n      this.props.setStages(newStages);\n    }\n    this.setState(\n      layoutGraph(newStages, this.state.layout, this.props.collapsed ?? false),\n    );\n  }\n\n  /**\n   * Is this stage currently selected?\n   */\n  private stageIsSelected = (stage?: StageInfo): boolean => {\n    const { selectedStage } = this.state;\n    return (selectedStage && stage && selectedStage.id === stage.id) || false;\n  };\n\n  render() {\n    const {\n      nodeColumns,\n      connections,\n      bigLabels,\n      smallLabels,\n      branchLabels,\n      measuredWidth,\n      measuredHeight,\n    } = this.state;\n\n    // Without these we get fire, so they're hardcoded\n    const outerDivStyle = {\n      position: \"relative\", // So we can put the labels where we need them\n      overflow: \"visible\", // So long labels can escape this component in layout\n    };\n\n    let nodes = [];\n    for (const column of nodeColumns) {\n      const topStageState = column.topStage?.state ?? Result.unknown;\n\n      for (const row of column.rows) {\n        for (const node of row) {\n          // If the topStage is still running but one of its child nodes has completed,\n          // the UI may incorrectly display the childs status instead of the topStages.\n          // To ensure consistency, override the nodes state with the topStages state.\n          // This issue is reproducible in the complexSmokes test.\n          if (\n            column.topStage &&\n            \"stage\" in node &&\n            node.stage &&\n            Array.isArray(column.topStage.children) &&\n            column.topStage.children.includes(node.stage) &&\n            this.props.collapsed\n          ) {\n            node.stage.state = topStageState;\n          }\n\n          nodes.push(node);\n        }\n      }\n    }\n\n    return (\n      <div className=\"PWGx-PipelineGraph-container\">\n        <div style={outerDivStyle as any} className=\"PWGx-PipelineGraph\">\n          <svg width={measuredWidth} height={measuredHeight}>\n            <GraphConnections\n              connections={connections}\n              layout={this.state.layout}\n            />\n\n            <SelectionHighlight\n              layout={this.state.layout}\n              nodeColumns={this.state.nodeColumns}\n              isStageSelected={this.stageIsSelected}\n            />\n          </svg>\n\n          {nodes.map((node) => (\n            <Node key={node.id} node={node} />\n          ))}\n          {bigLabels.map((label) => (\n            <BigLabel\n              key={label.key}\n              details={label}\n              layout={this.state.layout}\n              measuredHeight={measuredHeight}\n              selectedStage={this.state.selectedStage}\n              isStageSelected={this.stageIsSelected}\n            />\n          ))}\n          {smallLabels.map((label) => (\n            <SmallLabel\n              key={label.key}\n              details={label}\n              layout={this.state.layout}\n              isStageSelected={this.stageIsSelected}\n            />\n          ))}\n          {branchLabels.map((label) => (\n            <SequentialContainerLabel\n              key={label.key}\n              details={label}\n              layout={this.state.layout}\n            />\n          ))}\n        </div>\n      </div>\n    );\n  }\n}\n","\n      import API from \"!../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../../../../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../../../../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../../../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../../../../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../../../../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../../../../../node_modules/css-loader/dist/cjs.js!../../../../../../node_modules/sass-loader/dist/cjs.js!./data-tree-view.scss\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../../../../../node_modules/css-loader/dist/cjs.js!../../../../../../node_modules/sass-loader/dist/cjs.js!./data-tree-view.scss\";\n       export default content && content.locals ? content.locals : undefined;\n","import React, { useCallback, useState } from \"react\";\nimport {\n  Result,\n  StageInfo,\n} from \"../../../pipeline-graph-view/pipeline-graph/main/\";\nimport StepStatus from \"../../../step-status/StepStatus\";\nimport \"./data-tree-view.scss\";\n\nexport default function DataTreeView({\n  stages,\n  selected,\n  onNodeSelect,\n}: DataTreeViewProps) {\n  const handleSelect = useCallback(\n    (event: React.MouseEvent, nodeId: string) => {\n      onNodeSelect(event, nodeId);\n    },\n    [onNodeSelect],\n  );\n\n  return (\n    <div id=\"tasks\">\n      {stages.map((stage) => (\n        <TreeNode\n          key={stage.id}\n          stage={stage}\n          selected={selected}\n          onSelect={handleSelect}\n        />\n      ))}\n    </div>\n  );\n}\n\nfunction TreeNode({ stage, selected, onSelect }: TreeNodeProps) {\n  const hasChildren = stage.children && stage.children.length > 0;\n  const isSelected = String(stage.id) === selected;\n  const [isExpanded, setIsExpanded] = useState<boolean>(\n    hasSelectedDescendant(stage),\n  );\n\n  function hasSelectedDescendant(stage: StageInfo): boolean {\n    return stage.children?.some(\n      (child) => String(child.id) === selected || hasSelectedDescendant(child),\n    );\n  }\n\n  const handleToggleClick = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    setIsExpanded(!isExpanded);\n  };\n\n  return (\n    <div className=\"task\">\n      <div className=\"pgv-tree-node-header\">\n        <button\n          onClick={(e) => {\n            if (!isSelected) {\n              onSelect(e, String(stage.id));\n            }\n            setIsExpanded(!isExpanded);\n          }}\n          className={`pgv-tree-item task-link ${\n            isSelected ? \"task-link--active\" : \"\"\n          }`}\n        >\n          <div>\n            <StepStatus\n              status={stage.state}\n              text={stage.name}\n              key={`status-${stage.id}`}\n              percent={stage.completePercent}\n              radius={10}\n            />\n            {stage.state === Result.running && (\n              <span className=\"pgv-tree-item__description\">\n                {stage.totalDurationMillis}\n              </span>\n            )}\n          </div>\n        </button>\n\n        {hasChildren && (\n          <button\n            className={`pgv-toggle-icon ${\n              isExpanded ? \"pgv-toggle-icon--active\" : \"\"\n            }`}\n            onClick={handleToggleClick}\n            aria-label={isExpanded ? \"Collapse\" : \"Expand\"}\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n              <path\n                fill=\"none\"\n                stroke=\"currentColor\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth=\"48\"\n                d=\"M184 112l144 144-144 144\"\n              />\n            </svg>\n          </button>\n        )}\n      </div>\n\n      {hasChildren && isExpanded && (\n        <div className=\"pgv-tree-children\">\n          {stage.children.map((child) => (\n            <TreeNode\n              key={child.id}\n              stage={child}\n              selected={selected}\n              onSelect={onSelect}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n\ninterface DataTreeViewProps {\n  stages: StageInfo[];\n  selected: string;\n  onNodeSelect: (event: React.MouseEvent, nodeId: string) => void;\n}\n\ninterface TreeNodeProps {\n  stage: StageInfo;\n  selected: string;\n  onSelect: (event: React.MouseEvent, id: string) => void;\n}\n","import { FunctionComponent } from \"react\";\nimport * as React from \"react\";\nimport { Result } from \"../pipeline-graph-view/pipeline-graph/main\";\nimport { decodeResultValue } from \"../pipeline-graph-view/pipeline-graph/main/PipelineGraphModel\";\nimport { getSymbolForResult } from \"../pipeline-graph-view/pipeline-graph/main/support/StatusIcons\";\n\ninterface Props {\n  status: Result;\n  text: string;\n  percent: number;\n  radius?: number;\n}\n\nconst Component: FunctionComponent<Props> = (props: Props) => {\n  const icon = getSymbolForResult(decodeResultValue(props.status));\n  return (\n    <>\n      <span className=\"task-icon-link\">{icon}</span>\n      <span className=\"task-link-text\">{props.text}</span>\n    </>\n  );\n};\n\nexport function getStepStatus(\n  status: Result,\n  complete?: number,\n  radius?: number,\n) {\n  const icon = getSymbolForResult(decodeResultValue(status));\n  return (\n    <div\n      className={`icon-sm`}\n      style={{\n        display: \"inline-block\",\n        paddingBottom: \"20px\",\n      }}\n    >\n      {icon}\n    </div>\n  );\n}\n\nexport default Component;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `#tasks{margin:0;padding-right:1.4rem}.pgv-tree-item{display:block !important;font-family:var(--font-family-sans) !important;padding-block:.3125rem !important;padding-right:1rem;cursor:pointer !important}.pgv-tree-item>div{display:flex;align-items:center;justify-content:stretch;text-wrap:nowrap;text-overflow:ellipsis;white-space:nowrap;gap:.65rem;mask-image:linear-gradient(90deg, white calc(100% - 2.5rem), transparent calc(100% - 1rem))}.pgv-tree-item .task-icon-link>div{display:contents}.pgv-tree-item svg{flex-shrink:0}.pgv-tree-item__description{color:var(--text-color-secondary)}.pgv-toggle-icon{position:absolute;top:.5rem;right:.5rem;width:1rem;height:1rem;margin-left:auto;transition:var(--standard-transition);appearance:none;background:none;padding:0;border:none;cursor:pointer;color:var(--text-color-secondary)}.pgv-toggle-icon--active{rotate:90deg}.pgv-toggle-icon svg{width:1rem;height:1rem}.pgv-toggle-icon svg *{stroke-width:42px !important}.pgv-toggle-icon:hover{color:var(--text-color)}.pgv-tree-node-header{position:relative}.pgv-tree-children{position:relative;display:flex;flex-direction:column;gap:.125rem;margin-top:.125rem;padding-left:calc(2.725rem + var(--jenkins-border-width, 2px));padding-right:.7rem}.pgv-tree-children::before{content:\"\";position:absolute;top:.375rem;left:calc(1.3875rem - var(--jenkins-border-width, 2px)/2);bottom:.375rem;background-color:var(--jenkins-border-color, color-mix(in srgb, var(--text-color-secondary) 25%, transparent));width:var(--jenkins-border-width, 2px);border-radius:10px}`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/main/frontend/pipeline-console-view/pipeline-console/main/data-tree-view.scss\"],\"names\":[],\"mappings\":\"AAAA,OACE,QAAA,CACA,oBAAA,CAGF,eACE,wBAAA,CACA,8CAAA,CACA,iCAAA,CACA,kBAAA,CACA,yBAAA,CAEA,mBACE,YAAA,CACA,kBAAA,CACA,uBAAA,CACA,gBAAA,CACA,sBAAA,CACA,kBAAA,CACA,UAAA,CACA,2FAAA,CAOF,mCACE,gBAAA,CAGF,mBACE,aAAA,CAGF,4BACE,iCAAA,CAIJ,iBACE,iBAAA,CACA,SAAA,CACA,WAAA,CACA,UAAA,CACA,WAAA,CACA,gBAAA,CACA,qCAAA,CACA,eAAA,CACA,eAAA,CACA,SAAA,CACA,WAAA,CACA,cAAA,CACA,iCAAA,CAEA,yBACE,YAAA,CAGF,qBACE,UAAA,CACA,WAAA,CAEA,uBACE,4BAAA,CAIJ,uBACE,uBAAA,CAIJ,sBACE,iBAAA,CAGF,mBACE,iBAAA,CACA,YAAA,CACA,qBAAA,CACA,WAAA,CACA,kBAAA,CAEA,8DAAA,CACA,mBAAA,CAEA,2BACE,UAAA,CACA,iBAAA,CACA,WAAA,CAEA,yDAAA,CAGA,cAAA,CAEA,8GAAA,CAKA,sCAAA,CACA,kBAAA\",\"sourcesContent\":[\"#tasks {\\n  margin: 0;\\n  padding-right: 1.4rem;\\n}\\n\\n.pgv-tree-item {\\n  display: block !important;\\n  font-family: var(--font-family-sans) !important;\\n  padding-block: 0.3125rem !important;\\n  padding-right: 1rem;\\n  cursor: pointer !important;\\n\\n  & > div {\\n    display: flex;\\n    align-items: center;\\n    justify-content: stretch;\\n    text-wrap: nowrap;\\n    text-overflow: ellipsis;\\n    white-space: nowrap;\\n    gap: 0.65rem;\\n    mask-image: linear-gradient(\\n      90deg,\\n      white calc(100% - 2.5rem),\\n      transparent calc(100% - 1rem)\\n    );\\n  }\\n\\n  .task-icon-link > div {\\n    display: contents;\\n  }\\n\\n  svg {\\n    flex-shrink: 0;\\n  }\\n\\n  &__description {\\n    color: var(--text-color-secondary);\\n  }\\n}\\n\\n.pgv-toggle-icon {\\n  position: absolute;\\n  top: 0.5rem;\\n  right: 0.5rem;\\n  width: 1rem;\\n  height: 1rem;\\n  margin-left: auto;\\n  transition: var(--standard-transition);\\n  appearance: none;\\n  background: none;\\n  padding: 0;\\n  border: none;\\n  cursor: pointer;\\n  color: var(--text-color-secondary);\\n\\n  &--active {\\n    rotate: 90deg;\\n  }\\n\\n  svg {\\n    width: 1rem;\\n    height: 1rem;\\n\\n    * {\\n      stroke-width: 42px !important;\\n    }\\n  }\\n\\n  &:hover {\\n    color: var(--text-color);\\n  }\\n}\\n\\n.pgv-tree-node-header {\\n  position: relative;\\n}\\n\\n.pgv-tree-children {\\n  position: relative;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.125rem;\\n  margin-top: 0.125rem;\\n  // TODO - var fallback can removed after baseline is moved >= 2.496\\n  padding-left: calc(1.35rem + 1.375rem + var(--jenkins-border-width, 2px));\\n  padding-right: 0.7rem;\\n\\n  &::before {\\n    content: \\\"\\\";\\n    position: absolute;\\n    top: 0.375rem;\\n    // TODO - var fallback can removed after baseline is moved >= 2.496\\n    left: calc(\\n      0.7rem + (1.375rem / 2) - (var(--jenkins-border-width, 2px) / 2)\\n    );\\n    bottom: 0.375rem;\\n    // TODO - var fallback can removed after baseline is moved >= 2.496\\n    background-color: var(\\n      --jenkins-border-color,\\n      color-mix(in srgb, var(--text-color-secondary) 25%, transparent)\\n    );\\n    // TODO - var fallback can removed after baseline is moved >= 2.496\\n    width: var(--jenkins-border-width, 2px);\\n    border-radius: 10px;\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n"],"names":["RenderState","React","connectorKey","leftNode","rightNode","key","options","DataTreeView","_ref","stages","selected","onNodeSelect","handleSelect","useCallback","event","nodeId","id","map","stage","TreeNode","onSelect","_ref2","hasChildren","children","length","isSelected","String","_useState","useState","hasSelectedDescendant","_stage$children","some","child","_useState2","isExpanded","setIsExpanded","className","onClick","e","concat","StepStatus","status","state","text","name","percent","completePercent","radius","Result","running","totalDurationMillis","stopPropagation","xmlns","viewBox","fill","stroke","strokeLinecap","strokeLinejoin","strokeWidth","d","styleTagTransform","setAttributes","insert","domAPI","insertStyleElement","locals","getStepStatus","complete","icon","getSymbolForResult","decodeResultValue","style","display","paddingBottom","props","___CSS_LOADER_EXPORT___","push","module"],"sourceRoot":""}